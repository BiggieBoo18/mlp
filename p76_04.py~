#coding: UTF-8

import numpy as np

def sigmoid(u, gain):
    ret = 1/(1+np.exp(-gain*u))

    return (ret)

def d_sigmoid(u, gain):
    ret = gain*u*(1-u)
    
    return (ret)

def main():
    x     = np.array(
            [[0,0,0],
             [1,0,1],
             [1,1,1],
             [1,1,0],
             [1,0,0],
             [0,0,1]]
            )      # 入力
    d     = np.array([0,0,1,0,1,1]) # 目標出力
    e     = 0.01  # 学習率
    epoch = 1   # 学習数
    i_num = 3+1    # 入力層数
    h_num = 5+1    # 隠れ層数
    o_num = 1      # 出力層数
    gain  = 1.2    # ゲイン
    w1    = np.random.uniform(-1.0, 1.0, (h_num,i_num))
    w2    = np.random.uniform(-1.0, 1.0, (o_num,h_num))
    
    for k in range(epoch):
        i  = np.random.randint(x.shape[0])
        X  = np.hstack([x[i],1.0])
        D  = np.array(d[i])
        u1 = np.dot(w1, X)
        z  = sigmoid(u1, gain)
        #print z
        u2 = np.dot(w2, z)
        y  = sigmoid(u2, gain)
        #print y
        delta_2 = y-D
        #print delta_2
        #print d_sigmoid(u1, gain)
        #print delta_2
        #print np.dot(w2.T, np.atleast_2d(delta_2))
        delta_1 = d_sigmoid(u1, gain)*np.dot(w2.T, np.atleast_2d(delta_2))
        print delta_1
        exit()
        X = np.atleast_2d(X)
        #print delta_1
        #print X.T
        #print np.dot(delta_1, X.T)
        exit()
        w1 = w1 - e*np.dot(delta_1,X)
        print w1
        #w2 = w2 - (e*delta_2)
        #print w2

if __name__ == "__main__":
    main()
